<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>I Love You Daniya â™¡</title>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">

  <style>
    body {
      margin: 0;
      height: 100vh;
      background: radial-gradient(circle at center, #0a1f5e 0%, #050a1a 100%);
      overflow: hidden;
      font-family: 'Pacifico', cursive;
      touch-action: none;
    }

    canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: block;
      z-index: 2;
    }

    .heart-svg {
      position: absolute;
      width: 60px;
      height: 60px;
      opacity: 0;
      animation: floatHeart linear forwards;
      filter: drop-shadow(0 0 15px #00f0ff);
      pointer-events: none;
      z-index: 1;
    }

    @keyframes floatHeart {
      0%   { transform: translateY(110vh) scale(0.5) rotate(0deg); opacity: 0; }
      10%  { opacity: 0.4; }
      90%  { opacity: 0.4; }
      100% { transform: translateY(-20vh) scale(1.8) rotate(360deg); opacity: 0; }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let particles = [];
    let time = 0;

    const phrase = "I love you Daniya ";
    let currentSpacing, currentFontSize, heartDensity;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const isMobile = canvas.width < 600;
      currentFontSize = isMobile ? 12 : 17; 
      currentSpacing = isMobile ? 10 : 16;
      heartDensity = isMobile ? 11 : 14; 

      buildHeartShape();
    }

    function buildHeartShape() {
      const newTargets = [];
      
      // We use the mathematical heart equation: (x^2+y^2-1)^3 - x^2*y^3 = 0
      for (let y = heartDensity; y >= -heartDensity; y--) {
        let lineIndex = 0; // Ensures each horizontal line starts at "I"
        for (let x = -heartDensity; x <= heartDensity; x++) {
          const nx = x / (heartDensity * 0.8);
          const ny = y / (heartDensity * 0.8);
          const equation = Math.pow(nx * nx + ny * ny - 1, 3) - (nx * nx * ny * ny * ny);

          if (equation <= 0) {
            newTargets.push({
              tx: canvas.width / 2 + x * currentSpacing,
              ty: canvas.height / 2 - y * currentSpacing,
              char: phrase[lineIndex % phrase.length],
              delay: Math.random() * 5 // For organic floating effect
            });
            lineIndex++;
          }
        }
      }

      // Map targets to particles with smooth transition
      particles = newTargets.map((t, i) => {
        const existing = particles[i];
        return {
          x: existing ? existing.x : Math.random() * canvas.width,
          y: existing ? existing.y : Math.random() * canvas.height,
          tx: t.tx,
          ty: t.ty,
          char: t.char,
          delay: t.delay
        };
      });
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      time += 0.02;

      const pulse = 1 + Math.sin(time * 1.5) * 0.05;

      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(pulse, pulse);
      ctx.translate(-canvas.width / 2, -canvas.height / 2);

      particles.forEach(p => {
        // Organic floating movement
        const floatY = Math.sin(time + p.delay) * 3;
        const floatX = Math.cos(time + p.delay) * 2;

        p.x += (p.tx - p.x) * 0.08;
        p.y += (p.ty - p.y) * 0.08;

        ctx.font = `${currentFontSize}px Pacifico`;
        ctx.textAlign = 'center';
        
        // Neon Blue Glow (Bloom)
        ctx.shadowColor = '#00f0ff';
        ctx.shadowBlur = 12;
        ctx.fillStyle = '#00f0ff';
        
        // Draw the character with the float offset
        ctx.fillText(p.char, p.x + floatX, p.y + floatY);
        
        // Secondary layer for extra brightness
        ctx.shadowBlur = 4;
        ctx.fillStyle = '#ffffff';
        ctx.fillText(p.char, p.x + floatX, p.y + floatY);
      });

      ctx.restore();
    }

    function animate() {
      draw();
      requestAnimationFrame(animate);
    }

    function createFloatingHeart() {
      const div = document.createElement('div');
      div.className = 'heart-svg';
      div.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="#00f0ff" stroke-width="1.5"><path d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"/></svg>`;
      div.style.left = Math.random() * 100 + 'vw';
      
      const duration = 8 + Math.random() * 10;
      div.style.animationDuration = duration + 's';
      
      document.body.appendChild(div);
      setTimeout(() => div.remove(), duration * 1000);
    }

    window.addEventListener('resize', resizeCanvas);

    window.onload = () => {
      resizeCanvas();
      animate();
      setInterval(createFloatingHeart, 600);
      // Start with a few hearts already on screen
      for(let i=0; i<5; i++) createFloatingHeart();
    };
  </script>
</body>
</html>